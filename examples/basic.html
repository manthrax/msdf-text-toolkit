<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>MSDF Basic Demo - MSDFString API</title>
  <link rel="stylesheet" href="../lib/demo-styles.css">
</head>
<body>
  <div id="controls" class="msdf-controls">
    <h2>ðŸŽ¨ MSDFString Demo</h2>
    
    <div class="section">
      <div class="control-group">
        <label>Text Content</label>
        <textarea id="textInput">Hello World!
MSDF Rendering</textarea>
        <button onclick="updateText()">Update Text</button>
      </div>
    </div>
    
    <div class="section">
      <h2>ðŸŒˆ Global Controls</h2>
      
      <div class="control-group">
        <label>Color</label>
        <div class="color-row">
          <input type="color" id="colorPicker" value="#ffffff">
          <input type="text" id="colorHex" value="#ffffff">
        </div>
      </div>
      
      <div class="control-group">
        <label>Outline Color</label>
        <div class="color-row">
          <input type="color" id="outlineColorPicker" value="#ff0000">
          <input type="text" id="outlineColorHex" value="#ff0000">
        </div>
      </div>
      
      <div class="control-group">
        <label>Thickness: <span class="value-display" id="thicknessValue">0.50</span></label>
        <input type="range" id="thickness" min="0" max="1" step="0.01" value="0.5">
      </div>
      
      <div class="control-group">
        <label>Outline: <span class="value-display" id="outlineValue">0.20</span></label>
        <input type="range" id="outline" min="0" max="0.5" step="0.01" value="0.2">
      </div>
      
      <div class="control-group">
        <label style="display: flex; align-items: center;">
          <input type="checkbox" id="glowMode" style="width: auto; margin-right: 8px;">
          <span>Glow Mode (soft alpha fade)</span>
        </label>
        <div style="font-size: 11px; color: #666; margin-top: 4px;">
          Unchecked = hard outline, Checked = soft glow/shadow
        </div>
      </div>
    </div>
    
    <div class="section">
      <h2>âœ¨ Per-Character Demo</h2>
      
      <div class="control-group">
        <label>Selected Character: <span class="value-display" id="selectedCharDisplay">None</span></label>
        <div style="font-size: 11px; color: #666; margin-top: 4px;">Click on any character to select</div>
      </div>
      
      <div class="control-group">
        <label>Character Color</label>
        <div class="color-row">
          <input type="color" id="charColorPicker" value="#8a8a8a">
        </div>
      </div>
      
      <div class="control-group">
        <label>Character Thickness: <span class="value-display" id="charThicknessValue">1.00</span></label>
        <input type="range" id="charThickness" min="0.1" max="3" step="0.1" value="1.0">
      </div>
      
      <button onclick="resetCharColors()">Reset All Characters</button>
    </div>
    
    <div class="info">
      <strong>Hybrid Control:</strong> Global Ã— Instance<br>
      Drag to orbit â€¢ Scroll to zoom
    </div>
  </div>

  <script type="importmap">
  {
    "imports": {
      "three": "https://unpkg.com/three@0.160.0/build/three.module.js",
      "three/addons/": "https://unpkg.com/three@0.160.0/examples/jsm/"
    }
  }
  </script>

  <script type="module">
    import * as THREE from 'three';
    import { MSDFString } from '../lib/MSDFString.js';
    import { initThreeScene, createAnimationLoop, setupRaycasting } from '../lib/threeHelpers.js';
    import { syncColorInputs, syncSliderValue, rgbToHex } from '../lib/uiHelpers.js';

    let threeContext;
    let textMesh;
    let selectedCharIndex = -1;

    const API_URL = 'http://localhost:3001';

    init();

    async function init() {
      // Initialize Three.js scene using shared utilities
      threeContext = initThreeScene(document.body, {
        bgColor: 0x0b0b0b,
        cameraPosition: { x: 0, y: 0, z: 5 }
      });

      // Load font using the unified API
      try {
        await MSDFString.loadFont('Montserrat-Bold', `${API_URL}/atlases`);
        createText();

        // Setup raycasting for character selection
        setupRaycasting(
          threeContext.camera,
          threeContext.renderer.domElement,
          (instanceId) => selectCharacter(instanceId),
          { objects: [textMesh] }
        );
      } catch (error) {
        console.error('Error loading font:', error);
      }

      // Setup UI event listeners
      setupControls();

      // Start animation loop
      createAnimationLoop(() => {
        // Animation logic can go here if needed
      }, threeContext);
    }

    function onMouseClick(event) {
      // This function is now handled by setupRaycasting helper
    }

    function selectCharacter(index) {
      if (index < 0 || index >= textMesh.getLength()) return;

      // Reset previous selection outline
      if (selectedCharIndex >= 0) {
        textMesh.setCharacterOutlineColor(selectedCharIndex, '#000000', 1.0);
      }

      selectedCharIndex = index;

      // Highlight selected character with outline
      textMesh.setCharacterOutlineColor(selectedCharIndex, '#ffff00', 1.0);
      textMesh.setGlobalOutlineThickness(0.05); // Ensure outline is visible

      // Update UI
      const text = textMesh.getText();
      const char = text[index] || '?';
      document.getElementById('selectedCharDisplay').textContent = `"${char}" (index: ${index})`;

      // Update color picker to match selected character's color
      // (This is just the instance multiplier, actual color is global Ã— instance)
      const colors = textMesh.geometry.attributes.instanceColor.array;
      const r = colors[index * 4 + 0] * 255;
      const g = colors[index * 4 + 1] * 255;
      const b = colors[index * 4 + 2] * 255;
      const hex = rgbToHex(r, g, b);
      document.getElementById('charColorPicker').value = hex;

      // Update thickness slider
      const thicknesses = textMesh.geometry.attributes.instanceThickness.array;
      const thickness = thicknesses[index * 2 + 0];
      document.getElementById('charThickness').value = thickness;
      document.getElementById('charThicknessValue').textContent = thickness.toFixed(2);
    }

    function createText() {
      if (textMesh) {
        threeContext.scene.remove(textMesh);
        textMesh.geometry.dispose();
        textMesh.material.dispose();
      }

      const text = document.getElementById('textInput').value;
      
      // Use font by name - it's already loaded and cached
      textMesh = new MSDFString({
        font: 'Montserrat-Bold',
        text: text,
        color: document.getElementById('colorPicker').value,
        outlineColor: document.getElementById('outlineColorPicker').value,
        thickness: parseFloat(document.getElementById('thickness').value),
        outlineThickness: parseFloat(document.getElementById('outline').value),
        maxLength: 200
      });

      threeContext.scene.add(textMesh);
    }

    function setupControls() {
      // Color pickers using shared helper
      syncColorInputs(
        document.getElementById('colorPicker'),
        document.getElementById('colorHex'),
        (color) => { if (textMesh) textMesh.setGlobalColor(color); }
      );

      syncColorInputs(
        document.getElementById('outlineColorPicker'),
        document.getElementById('outlineColorHex'),
        (color) => { if (textMesh) textMesh.setGlobalOutlineColor(color); }
      );

      // Sliders using shared helper
      syncSliderValue(
        document.getElementById('thickness'),
        document.getElementById('thicknessValue'),
        (val) => { if (textMesh) textMesh.setGlobalThickness(val); }
      );

      syncSliderValue(
        document.getElementById('outline'),
        document.getElementById('outlineValue'),
        (val) => { if (textMesh) textMesh.setGlobalOutlineThickness(val); }
      );

      // Glow mode checkbox
      document.getElementById('glowMode').addEventListener('change', (e) => {
        if (!textMesh) return;
        if (e.target.checked) {
          textMesh.enableGlow();
        } else {
          textMesh.disableGlow();
        }
      });

      // Character controls - auto-apply to selected character
      document.getElementById('charColorPicker').addEventListener('input', (e) => {
        if (!textMesh || selectedCharIndex < 0) return;
        textMesh.setCharacterColor(selectedCharIndex, e.target.value, 1.0);
      });

      syncSliderValue(
        document.getElementById('charThickness'),
        document.getElementById('charThicknessValue'),
        (val) => {
          if (!textMesh || selectedCharIndex < 0) return;
          textMesh.setCharacterThickness(selectedCharIndex, val, 1.0);
        }
      );
    }

    window.updateText = function() {
      selectedCharIndex = -1;
      document.getElementById('selectedCharDisplay').textContent = 'None';
      createText();
    };

    window.resetCharColors = function() {
      if (!textMesh) return;
      selectedCharIndex = -1;
      document.getElementById('selectedCharDisplay').textContent = 'None';
      textMesh.resetCharacterAttributes();
    };
  </script>
</body>
</html>
