<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>MSDF Generator - Native Backend</title>
  <style>
    * {
      margin: 0;
      padding: 0;
      box-sizing: border-box;
    }

    body {
      font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
      background: #0b0b0b;
      color: #ddd;
      overflow: hidden;
    }

    #container {
      display: grid;
      grid-template-columns: 350px 1fr;
      height: 100vh;
    }

    #sidebar {
      background: #161616;
      border-right: 1px solid #333;
      overflow-y: auto;
      overflow-x: hidden;
      padding: 20px;
      max-height: 100vh;
      display: flex;
      flex-direction: column;
    }

    h1 {
      font-size: 20px;
      margin-bottom: 20px;
      color: #fff;
    }

    .section {
      margin-bottom: 25px;
    }

    .section-title {
      font-size: 13px;
      font-weight: 600;
      color: #999;
      margin-bottom: 10px;
      text-transform: uppercase;
      letter-spacing: 0.5px;
    }

    label {
      display: block;
      font-size: 13px;
      margin-bottom: 5px;
      color: #aaa;
    }

    input[type="text"],
    input[type="number"],
    input[type="file"],
    select,
    textarea {
      width: 100%;
      padding: 8px 10px;
      background: #222;
      border: 1px solid #333;
      border-radius: 4px;
      color: #ddd;
      font-size: 13px;
      margin-bottom: 12px;
    }

    input[type="file"] {
      padding: 6px;
    }

    input[type="range"] {
      width: 100%;
      margin-bottom: 12px;
      accent-color: #60a5fa;
    }

    input[type="color"] {
      width: 100%;
      height: 40px;
      padding: 2px;
      background: #222;
      border: 1px solid #333;
      border-radius: 4px;
      cursor: pointer;
      margin-bottom: 12px;
    }

    textarea {
      font-family: 'Courier New', monospace;
      resize: vertical;
      min-height: 80px;
    }
    
    label span {
      float: right;
      color: #60a5fa;
      font-weight: 600;
    }

    button {
      width: 100%;
      padding: 12px;
      background: #60a5fa;
      border: none;
      border-radius: 4px;
      color: #fff;
      font-weight: 600;
      font-size: 14px;
      cursor: pointer;
      transition: background 0.2s;
    }

    button:hover {
      background: #3b82f6;
    }

    button:disabled {
      background: #444;
      cursor: not-allowed;
    }

    .preset-buttons {
      display: grid;
      grid-template-columns: 1fr 1fr;
      gap: 8px;
      margin-bottom: 12px;
    }

    .preset-buttons button {
      font-size: 12px;
      padding: 8px;
    }

    #viewer {
      position: relative;
      background: #0b0b0b;
    }

    #canvas-container {
      width: 100%;
      height: 100%;
    }

    /* Custom scrollbar for sidebar */
    #sidebar::-webkit-scrollbar {
      width: 8px;
    }

    #sidebar::-webkit-scrollbar-track {
      background: #1a1a1a;
    }

    #sidebar::-webkit-scrollbar-thumb {
      background: #444;
      border-radius: 4px;
    }

    #sidebar::-webkit-scrollbar-thumb:hover {
      background: #555;
    }

    #status {
      position: absolute;
      top: 20px;
      left: 20px;
      background: rgba(0, 0, 0, 0.8);
      padding: 12px 16px;
      border-radius: 6px;
      font-size: 13px;
      max-width: 400px;
      backdrop-filter: blur(10px);
    }

    #status.error {
      background: rgba(220, 38, 38, 0.9);
    }

    #status.success {
      background: rgba(34, 197, 94, 0.9);
    }

    .hidden {
      display: none;
    }

    #log {
      background: #0a0a0a;
      padding: 12px;
      border-radius: 4px;
      font-family: 'Courier New', monospace;
      font-size: 11px;
      color: #888;
      max-height: 150px;
      overflow-y: auto;
      margin-top: 12px;
      line-height: 1.5;
    }

    .log-line {
      margin: 2px 0;
    }

    .log-line.info {
      color: #60a5fa;
    }

    .log-line.error {
      color: #f87171;
    }

    #spinner {
      position: fixed;
      top: 0;
      left: 0;
      right: 0;
      bottom: 0;
      background: rgba(11, 11, 11, 0.85);
      backdrop-filter: blur(4px);
      z-index: 9999;
      align-items: center;
      justify-content: center;
      flex-direction: column;
      display: none;
    }

    #spinner.active {
      display: flex;
    }

    .spinner-ring {
      border: 4px solid #333;
      border-top: 4px solid #60a5fa;
      border-radius: 50%;
      width: 60px;
      height: 60px;
      animation: spin 1s linear infinite;
    }

    @keyframes spin {
      0% { transform: rotate(0deg); }
      100% { transform: rotate(360deg); }
    }

    .spinner-text {
      color: #ddd;
      margin-top: 1.5rem;
      font-size: 16px;
      font-weight: 500;
    }

    .help-text {
      font-size: 11px;
      color: #666;
      margin-top: -8px;
      margin-bottom: 12px;
      line-height: 1.4;
    }
  </style>
</head>
<body>
  <div id="container">
    <div id="sidebar">
      <h1>MSDF Generator</h1>

      <div class="section">
        <div class="section-title">ðŸ“š Examples</div>
        <div style="display: flex; gap: 8px; flex-wrap: wrap;">
          <a href="/examples/basic.html" target="_blank" style="color: #0f0; text-decoration: none; font-size: 12px;">Basic Demo</a>
          <span style="color: #444;">â€¢</span>
          <a href="/examples/matrix-mode.html" target="_blank" style="color: #0f0; text-decoration: none; font-size: 12px;">Matrix Mode</a>
        </div>
      </div>
      
      <div class="section">
        <div class="section-title">Font Source</div>
        
        <label for="fontFile">Upload Font</label>
        <input type="file" id="fontFile" accept=".ttf,.otf,.woff,.woff2">
        <div class="help-text">or select from project fonts below</div>
        
        <label for="fontSelect">Project Fonts</label>
        <select id="fontSelect">
          <option value="">-- Select font --</option>
        </select>
      </div>

      <button id="generateBtn" onclick="generate()" style="margin-bottom: 20px;">ðŸš€ Generate Atlas</button>

      <div id="downloadSection" class="section hidden">
        <div class="section-title">Download Atlas</div>
        <button onclick="downloadAtlasPNG()" style="margin-bottom: 8px;">
          ðŸ“¥ Download PNG
        </button>
        <button onclick="downloadAtlasJSON()">
          ðŸ“¥ Download JSON
        </button>
      </div>

      <div class="section">
        <div class="section-title">Presets</div>
        <div class="preset-buttons">
          <button onclick="applyPreset('default')">Default</button>
          <button onclick="applyPreset('mtsdf')">MTSDF</button>
          <button onclick="applyPreset('production')">Production</button>
          <button onclick="applyPreset('mobile')">Mobile</button>
        </div>
      </div>

      <div class="section">
        <div class="section-title">Atlas Settings</div>
        
        <label for="fieldType">Field Type</label>
        <select id="fieldType">
          <option value="msdf">MSDF (Multi-channel)</option>
          <option value="sdf">SDF (Single-channel)</option>
          <option value="psdf">PSDF (Pseudo-distance)</option>
        </select>
        <div class="help-text">MSDF recommended for most uses</div>
        
        <label for="fontSize">Font Size (px)</label>
        <input type="number" id="fontSize" value="42" min="12" max="128">
        
        <label for="textureWidth">Atlas Width</label>
        <input type="number" id="textureWidth" value="1024" step="256" min="256" max="4096">
        
        <label for="textureHeight">Atlas Height</label>
        <input type="number" id="textureHeight" value="1024" step="256" min="256" max="4096">
        
        <label for="distanceRange">Distance Range</label>
        <input type="number" id="distanceRange" value="4" min="1" max="16" step="0.5">
      </div>

      <div class="section">
        <div class="section-title">Character Set</div>
        <label for="charset">Characters to Include</label>
        <textarea id="charset" placeholder="Leave empty for ASCII printable"></textarea>
        <div class="help-text">Default: all ASCII printable (space through ~)</div>
      </div>

      <div class="section">
        <div class="section-title">Text Rendering</div>
        
        <label for="thickness">Thickness: <span id="thicknessValue">0.50</span></label>
        <input type="range" id="thickness" min="0" max="1" step="0.01" value="0.5">
        
        <label for="outlineWidth">Outline Width: <span id="outlineWidthValue">0.00</span></label>
        <input type="range" id="outlineWidth" min="0" max="0.3" step="0.01" value="0">
        
        <label for="outlineColor">Outline Color</label>
        <input type="color" id="outlineColor" value="#000000">
        
        <label style="display: flex; align-items: center; margin-top: 8px;">
          <input type="checkbox" id="matrixMode" style="width: auto; margin-right: 8px;">
          <span style="float: none;">Matrix Mode ðŸŸ¢</span>
        </label>
      </div>

      <div id="log" class="hidden"></div>
    </div>

    <div id="viewer">
      <div id="canvas-container"></div>
      <div id="status" class="hidden"></div>
    </div>
  </div>

  <div id="spinner">
    <div class="spinner-ring"></div>
    <div class="spinner-text">Generating atlas...</div>
    <small style="color:#9aa;margin-top:0.5rem;">This may take a moment</small>
  </div>

  <script type="importmap">
  {
    "imports": {
      "three": "https://cdn.jsdelivr.net/npm/three@0.169.0/build/three.module.js",
      "three/addons/": "https://cdn.jsdelivr.net/npm/three@0.169.0/examples/jsm/"
    }
  }
  </script>

  <script type="module">
    import * as THREE from 'three';
    import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
    import { MSDFString } from '/lib/MSDFString.js';
    import { initThreeScene, createAnimationLoop } from '/lib/threeHelpers.js';
    import { MatrixRain } from '/lib/effects/matrixRain.js';
    import { applyRainbowGradient } from '/lib/textPreview.js';

    const API_URL = '/api';
    
    let scene, camera, renderer, controls;
    let currentAtlas = null;
    let previewMesh = null;
    let matrixEffect = null; // Matrix animation effect
    
    // Store generated atlas data for download
    let generatedAtlasData = {
      texture: null,
      atlas: null,
      fontName: null
    };

    // Initialize Three.js
    function initThree() {
      const container = document.getElementById('canvas-container');
      
      scene = new THREE.Scene();
      scene.background = new THREE.Color(0x0b0b0b);
      
      camera = new THREE.PerspectiveCamera(
        50,
        container.clientWidth / container.clientHeight,
        0.1,
        1000
      );
      camera.position.set(0, 0, 5);
      
      renderer = new THREE.WebGLRenderer({ antialias: true });
      renderer.setSize(container.clientWidth, container.clientHeight);
      container.appendChild(renderer.domElement);
      
      controls = new OrbitControls(camera, renderer.domElement);
      controls.enableDamping = true;
      
      window.addEventListener('resize', onResize);
      animate();
    }

    function onResize() {
      const container = document.getElementById('canvas-container');
      camera.aspect = container.clientWidth / container.clientHeight;
      camera.updateProjectionMatrix();
      renderer.setSize(container.clientWidth, container.clientHeight);
    }

    function animate() {
      requestAnimationFrame(animate);
      controls.update();
      
      // Update Matrix animation if active
      if (matrixEffect) {
        matrixEffect.update();
      }
      
      renderer.render(scene, camera);
    }

    // Load available fonts
    async function loadFonts() {
      try {
        const response = await fetch(`${API_URL}/fonts`);
        const data = await response.json();
        const select = document.getElementById('fontSelect');
        data.fonts.forEach(font => {
          const option = document.createElement('option');
          option.value = `fonts/${font}`;
          option.textContent = font;
          select.appendChild(option);
        });
        
        // Select Montserrat-Bold by default (sensible default)
        const montserrat = data.fonts.find(f => f.includes('Montserrat-Bold'));
        if (montserrat) {
          select.value = `fonts/${montserrat}`;
        }
        
        // Auto-generate if debug=true
        const urlParams = new URLSearchParams(window.location.search);
        if (urlParams.get('debug') === 'true') {
          setTimeout(() => generate(), 200);
        }
      } catch (error) {
        log(`Failed to load fonts: ${error.message}`, 'error');
      }
    }

    // Generate atlas
    window.generate = async function() {
      const fileInput = document.getElementById('fontFile');
      const fontSelect = document.getElementById('fontSelect');
      
      let fontFile = fileInput.files[0];
      let fontPath = fontSelect.value;
      
      if (!fontFile && !fontPath) {
        showStatus('Please select or upload a font file', 'error');
        return;
      }
      
      // If using project font, need to fetch it first
      if (!fontFile && fontPath) {
        try {
          // fontPath is like "fonts/Montserrat-Bold.ttf"
          // Static files are served from msdf-generator-browser/ root
          const response = await fetch(`/${fontPath}`);
          if (!response.ok) {
            throw new Error(`HTTP ${response.status}: ${response.statusText}`);
          }
          const blob = await response.blob();
          fontFile = new File([blob], fontPath.split('/').pop(), { type: 'font/ttf' });
        } catch (error) {
          showStatus(`Failed to load font: ${error.message}`, 'error');
          log(`Font fetch error: ${error.message}`, 'error');
          return;
        }
      }
      
      const options = {
        fieldType: document.getElementById('fieldType').value,
        fontSize: document.getElementById('fontSize').value,
        textureWidth: document.getElementById('textureWidth').value,
        textureHeight: document.getElementById('textureHeight').value,
        distanceRange: document.getElementById('distanceRange').value,
        charset: document.getElementById('charset').value || undefined
      };
      
      const formData = new FormData();
      formData.append('font', fontFile);
      formData.append('options', JSON.stringify(options));
      
      showSpinner(true);
      clearLog();
      log('Sending generation request to server...', 'info');
      
      try {
        const response = await fetch(`${API_URL}/generate`, {
          method: 'POST',
          body: formData
        });
        
        const result = await response.json();
        
        if (!result.success) {
          throw new Error(result.error);
        }
        
        log('Atlas generated successfully!', 'info');
        log(`Glyphs: ${result.atlas.chars.length}`, 'info');
        
        // Store atlas data for download
        generatedAtlasData.texture = result.texture;
        generatedAtlasData.atlas = result.atlas;
        generatedAtlasData.fontName = fontFile.name.replace(/\.[^/.]+$/, ''); // Remove extension
        
        // Display atlas
        displayAtlas(result.texture, result.atlas);
        showStatus(`âœ“ Generated ${result.atlas.chars.length} glyphs`, 'success');
        
        // Show download section
        document.getElementById('downloadSection').classList.remove('hidden');
        
      } catch (error) {
        log(`Generation failed: ${error.message}`, 'error');
        showStatus(`âœ— Generation failed: ${error.message}`, 'error');
      } finally {
        showSpinner(false);
      }
    };

    // Generate text mesh using MSDFString API
    function generateTextMesh(text, atlasData, atlasTexture) {
      if (!atlasData || !atlasTexture) {
        console.warn('generateTextMesh: Missing atlasData or atlasTexture');
        return null;
      }
      
      try {
        const textMesh = new MSDFString({
          font: { texture: atlasTexture, data: atlasData },
          text: text,
          color: '#00ff88',  // Start with a nice teal
          outlineColor: '#000000',
          thickness: 0.5,
          outlineThickness: 0.0,
          maxLength: 1000
        });
        
        // Set appropriate fontSize for visibility (not in constructor)
        textMesh.setText(text, {
          fontSize: 0.015,  // Scale text to be visible
          align: 'center'
        });
        
        // Apply rainbow gradient using shared helper
        applyRainbowGradient(textMesh);
        
        return textMesh;
      } catch (error) {
        console.error('Error creating MSDFString:', error);
        log(`Error creating text mesh: ${error.message}`, 'error');
        return null;
      }
    }

    // Matrix Mode Animation (using shared module)
    function initMatrixMode() {
      if (!previewMesh || !currentAtlas) return;
      
      // Enable glow mode for matrix effect
      previewMesh.enableGlow();
      
      // Create matrix rain effect using shared module
      matrixEffect = new MatrixRain(previewMesh, {
        columns: 300,
        charsPerColumn: 45,
        spacing: 0.4,
        charSize: 0.12,
        speedMin: 0.015,
        speedMax: 0.065,
        viewHeight: 10,
        densityFactor: 1.0
      });
    }
    
    function stopMatrixMode() {
      if (matrixEffect) {
        matrixEffect.stop();
        matrixEffect.dispose();
        matrixEffect = null;
      }
      
      // Disable glow mode
      if (previewMesh) {
        previewMesh.disableGlow();
      }
    }

    // Display atlas in 3D view
    function displayAtlas(textureDataUrl, atlasData) {
      // Stop Matrix mode if active
      stopMatrixMode();
      const matrixCheckbox = document.getElementById('matrixMode');
      if (matrixCheckbox) matrixCheckbox.checked = false;
      
      // Remove old meshes
      if (previewMesh) {
        scene.remove(previewMesh);
        previewMesh.geometry.dispose();
        previewMesh.material.dispose();
      }
      if (window.atlasPlane) {
        scene.remove(window.atlasPlane);
        window.atlasPlane.geometry.dispose();
        window.atlasPlane.material.dispose();
      }
      
      // Load texture
      const loader = new THREE.TextureLoader();
      const texture = loader.load(textureDataUrl);
      texture.colorSpace = THREE.NoColorSpace;
      texture.minFilter = THREE.LinearMipMapLinearFilter; // Trilinear filtering for better far-distance quality
      texture.magFilter = THREE.LinearFilter;
      texture.flipY = false;
      texture.generateMipmaps = true; // Ensure mipmaps are generated
      // Store atlas
      currentAtlas = { texture, data: atlasData };
      
      // Create atlas preview plane (at the back)
      const atlasGeo = new THREE.PlaneGeometry(4, 4);
      const atlasMat = new THREE.MeshBasicMaterial({
        map: texture,
        side: THREE.DoubleSide,
        transparent: true,
        opacity: 0.3
      });
      window.atlasPlane = new THREE.Mesh(atlasGeo, atlasMat);
      window.atlasPlane.position.z = -5;
      scene.add(window.atlasPlane);
      
      // Generate sample text with more variety (repeated for Matrix mode)
      const baseSampleText = 'MSDF Text Rendering!\n' +
                        'The quick brown fox jumps over the lazy dog.\n' +
                        'ABCDEFGHIJKLMNOPQRSTUVWXYZ\n' +
                        'abcdefghijklmnopqrstuvwxyz\n' +
                        '0123456789 !@#$%^&*()_+-=[]{}\\|;:\'",.<>?/~`';
      // Repeat text to ensure enough instances for Matrix mode (300 columns Ã— 45 chars = 13500+)
      const sampleText = (baseSampleText + '\n').repeat(100);
      previewMesh = generateTextMesh(sampleText, atlasData, texture);
      
      if (previewMesh) {
        scene.add(previewMesh);
      }
    }

    // Presets
    window.applyPreset = function(preset) {
      const presets = {
        default: {
          fieldType: 'msdf',
          fontSize: 42,
          textureWidth: 1024,
          textureHeight: 1024,
          distanceRange: 4
        },
        mtsdf: {
          fieldType: 'msdf',
          fontSize: 48,
          textureWidth: 1024,
          textureHeight: 1024,
          distanceRange: 6
        },
        production: {
          fieldType: 'msdf',
          fontSize: 48,
          textureWidth: 2048,
          textureHeight: 2048,
          distanceRange: 6
        },
        mobile: {
          fieldType: 'msdf',
          fontSize: 36,
          textureWidth: 512,
          textureHeight: 512,
          distanceRange: 4
        }
      };
      
      const config = presets[preset];
      if (config) {
        document.getElementById('fieldType').value = config.fieldType;
        document.getElementById('fontSize').value = config.fontSize;
        document.getElementById('textureWidth').value = config.textureWidth;
        document.getElementById('textureHeight').value = config.textureHeight;
        document.getElementById('distanceRange').value = config.distanceRange;
        log(`Applied ${preset} preset`, 'info');
      }
    };

    // UI helpers
    function showSpinner(show) {
      const spinner = document.getElementById('spinner');
      spinner.className = show ? 'active' : '';
      document.getElementById('generateBtn').disabled = show;
    }

    function showStatus(message, type = 'info') {
      const status = document.getElementById('status');
      status.textContent = message;
      status.className = type;
      status.classList.remove('hidden');
      setTimeout(() => {
        if (type !== 'error') {
          status.classList.add('hidden');
        }
      }, type === 'error' ? 5000 : 3000);
    }

    function log(message, type = 'info') {
      const logEl = document.getElementById('log');
      logEl.classList.remove('hidden');
      const line = document.createElement('div');
      line.className = `log-line ${type}`;
      line.textContent = `[${new Date().toLocaleTimeString()}] ${message}`;
      logEl.appendChild(line);
      logEl.scrollTop = logEl.scrollHeight;
    }

    function clearLog() {
      document.getElementById('log').innerHTML = '';
    }

    // Rendering control event listeners
    function setupRenderingControls() {
      const thicknessSlider = document.getElementById('thickness');
      const thicknessValue = document.getElementById('thicknessValue');
      const outlineWidthSlider = document.getElementById('outlineWidth');
      const outlineWidthValue = document.getElementById('outlineWidthValue');
      const outlineColorPicker = document.getElementById('outlineColor');
      const matrixModeCheckbox = document.getElementById('matrixMode');
      
      thicknessSlider.addEventListener('input', (e) => {
        const value = parseFloat(e.target.value);
        thicknessValue.textContent = value.toFixed(2);
        
        if (previewMesh && previewMesh.setGlobalThickness) {
          previewMesh.setGlobalThickness(value);
        }
      });
      
      outlineWidthSlider.addEventListener('input', (e) => {
        const value = parseFloat(e.target.value);
        outlineWidthValue.textContent = value.toFixed(2);
        
        if (previewMesh && previewMesh.setGlobalOutlineThickness) {
          previewMesh.setGlobalOutlineThickness(value);
        }
      });
      
      outlineColorPicker.addEventListener('input', (e) => {
        if (previewMesh && previewMesh.setGlobalOutlineColor) {
          previewMesh.setGlobalOutlineColor(e.target.value);
        }
      });
      
      matrixModeCheckbox.addEventListener('change', (e) => {
        if (e.target.checked) {
          // Enable Matrix mode
          initMatrixMode();
          // Hide atlas plane but KEEP orbit controls for 3D navigation!
          if (window.atlasPlane) window.atlasPlane.visible = false;
          controls.enabled = true; // Keep controls enabled for 3D exploration
          // Position camera for good 3D view of the dense grid
          camera.position.set(0, 1, 3.5); // Closer view for tighter spacing
          camera.lookAt(0, 0, 0);
          controls.update();
        } else {
          // Disable Matrix mode
          stopMatrixMode();
          // Restore atlas plane
          if (window.atlasPlane) window.atlasPlane.visible = true;
          controls.enabled = true;
          // Regenerate normal text display
          if (currentAtlas) {
            displayAtlas(currentAtlas.texture.image.src, currentAtlas.data);
          }
        }
      });
    }

    // Download functions
    window.downloadAtlasPNG = function() {
      if (!generatedAtlasData.texture) {
        showStatus('No atlas generated yet', 'error');
        return;
      }
      
      // Convert base64 data URL to blob
      const base64Data = generatedAtlasData.texture.split(',')[1];
      const byteCharacters = atob(base64Data);
      const byteNumbers = new Array(byteCharacters.length);
      
      for (let i = 0; i < byteCharacters.length; i++) {
        byteNumbers[i] = byteCharacters.charCodeAt(i);
      }
      
      const byteArray = new Uint8Array(byteNumbers);
      const blob = new Blob([byteArray], { type: 'image/png' });
      
      // Create download link
      const url = URL.createObjectURL(blob);
      const a = document.createElement('a');
      a.href = url;
      a.download = `${generatedAtlasData.fontName || 'atlas'}.png`;
      document.body.appendChild(a);
      a.click();
      document.body.removeChild(a);
      URL.revokeObjectURL(url);
      
      log(`Downloaded ${a.download}`, 'info');
      showStatus(`âœ“ Downloaded PNG`, 'success');
    };
    
    window.downloadAtlasJSON = function() {
      if (!generatedAtlasData.atlas) {
        showStatus('No atlas generated yet', 'error');
        return;
      }
      
      // Convert JSON to blob
      const jsonStr = JSON.stringify(generatedAtlasData.atlas, null, 2);
      const blob = new Blob([jsonStr], { type: 'application/json' });
      
      // Create download link
      const url = URL.createObjectURL(blob);
      const a = document.createElement('a');
      a.href = url;
      a.download = `${generatedAtlasData.fontName || 'atlas'}.json`;
      document.body.appendChild(a);
      a.click();
      document.body.removeChild(a);
      URL.revokeObjectURL(url);
      
      log(`Downloaded ${a.download}`, 'info');
      showStatus(`âœ“ Downloaded JSON`, 'success');
    };

    // Load an existing atlas for preview using MSDFString API
    async function loadExistingAtlas(fontName) {
      try {
        log(`Loading existing atlas: ${fontName}...`, 'info');
        
        // Use MSDFString's unified font loading API
        const fontData = await MSDFString.loadFont(fontName, '/atlases');
        
        // Convert texture to data URL for storage/download
        const canvas = document.createElement('canvas');
        canvas.width = fontData.texture.image.width;
        canvas.height = fontData.texture.image.height;
        const ctx = canvas.getContext('2d');
        ctx.drawImage(fontData.texture.image, 0, 0);
        const textureDataUrl = canvas.toDataURL('image/png');
        
        // Store as generated data for download
        generatedAtlasData.texture = textureDataUrl;
        generatedAtlasData.atlas = fontData.data;
        generatedAtlasData.fontName = fontName;
        
        // Display the atlas
        displayAtlas(textureDataUrl, fontData.data);
        
        // Create a demo text mesh in the 3D scene
        if (previewMesh) {
          scene.remove(previewMesh);
          previewMesh.geometry.dispose();
          previewMesh.material.dispose();
        }
        
        previewMesh = new MSDFString({
          font: fontName,
          text: 'MSDF Text\nAtlas Loaded!',
          fontSize: 0.015,
          align: 'center',
          color: '#ffffff',
          outlineColor: '#000000',
          thickness: 0.5,
          outlineThickness: 0.05
        });
        
        scene.add(previewMesh);
        
        log(`âœ“ Loaded ${fontName} (${fontData.data.chars.length} glyphs)`, 'info');
        showStatus(`âœ“ Loaded ${fontName}`, 'success');
        
        // Show download section
        document.getElementById('downloadSection').classList.remove('hidden');
      } catch (error) {
        console.error('Failed to load existing atlas:', error);
        log(`Could not load ${fontName}: ${error.message}`, 'info');
      }
    }

    // Initialize
    initThree();
    loadFonts();
    setupRenderingControls();
    
    // Auto-load Zenzai Itacha font on startup for immediate visual
    setTimeout(() => {
      loadExistingAtlas('Zenzai Itacha');
    }, 500);
    
    // Auto-generate on load for debugging (only if ?debug=true)
    const urlParams = new URLSearchParams(window.location.search);
    if (urlParams.get('debug') === 'true') {
      setTimeout(() => {
        const fontSelect = document.getElementById('fontSelect');
        const montserratOption = Array.from(fontSelect.options).find(opt => opt.value.includes('Montserrat-Bold'));
        if (montserratOption) {
          fontSelect.value = montserratOption.value;
          generate();
        }
      }, 500);
      log('Debug mode: Auto-generating Montserrat-Bold', 'info');
    }
    
    log('Ready to generate MSDF atlases', 'info');
  </script>
</body>
</html>

